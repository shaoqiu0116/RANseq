---
title: An R Markdown document converted from "/content/hhp_rna_seq.ipynb"
output: html_document
---

## Import

```{r}
if (!requireNamespace("BiocManager")) install.packages("BiocManager")
BiocManager::install(c("BiasedUrn", "Glimma", "GO.db", "edgeR", "gplots", "limma",
    "NMF", "org.Mm.eg.db", "RColorBrewer", "sva"))
```

```{r}
install.packages(c("here", "statmod", "xtable"))
```

```{r}
# First, let's load all the packages we will need to analyse the data.
library(edgeR)
library(ggplot2)
library(Glimma)
library(gplots)
library(here)
library(limma)
library(NMF)
library(org.Mm.eg.db)
library(RColorBrewer)
library(statmod)
library(sva)
library(tidyverse)
```

## Reading data

```{r}
filename <- here()
filename
```

```{r}
list.files(filename, recursive = TRUE)  # list all the files in this directory
```

```{r}
sampleinfo <- read.delim(here(filename, "./input/Counts/SampleInfo.txt"), stringsAsFactors = TRUE)  # for google calab
# sampleinfo <- read.delim('./SampleInfo.txt', stringsAsFactors = TRUE) # read
# for google colab
sampleinfo  # with treatment and batch information
```

```{r}
files <- c("Control_1_counts.txt", "Control_2_counts.txt", "Control_3_counts.txt",
    "10min_1_counts.txt", "10min_2_counts.txt", "10min_3_counts.txt", "2h_1_counts.txt",
    "2h_2_counts.txt", "2h_3_counts.txt", "24h_1_counts.txt", "24h_2_counts.txt",
    "24h_3_counts.txt")
# all the files
read.delim(here(filename, "/input/Counts/", files[1]), nrow = 5)  # test first file
# read.delim(here(filename, './', files[1]), nrow = 5) # test first file counts
# file with geneid and counts
```

## Create DGE object

```{r}
x <- readDGE(here(filename, "/input/Counts/", files), columns = c(1, 2))
# x <- readDGE(here(filename, './', files), columns = c(1, 2)) create DGE
# objects with all the counts files, only two columns
head(x)  # x with samples, counts, 
class(x)
dim(x)
names(x)
```

```{r}
sampleinfo$SampleName
```

```{r}
colnames(x) <- sampleinfo$SampleName
```

```{r}
x$samples  # x, DGE objects with sample and counts dataframes
head(x$counts)
```

```{r}
group <- sampleinfo$Treatment
# Take a look
group
# Add the group information into the DGEList
x$samples$group <- group
x$samples
```

## Add annotation

```{r}
# Annotate the genes.
head(x$counts)
dim(x$counts)
geneid <- rownames(x)
genes <- AnnotationDbi::select(org.Mm.eg.db, keys = geneid, columns = c("ENTREZID",
    "SYMBOL", "GENENAME"), keytype = "SYMBOL")
# retrieve the ENTRZIS, GENENAME based on the SYMBOL keytype
head(genes)
genes <- genes[!duplicated(genes$ENTREZID), ]
```

```{r}
x <- x[genes$SYMBOL, ]  # keep only the genes with corresponding SYMBOLs in genes
head(x)
```

```{r}
x$genes <- genes  # add genes annotation to x
head(x)  # x has samples, counts, genes annotation attributes
table(genes$SYMBOL == rownames(x))  # test the genes and x rownames are the same
# 32879 genes total
```

## Batch effect correction with ComBat-seq

```{r}
# use ComBat-seq to correct batch effect, keep the counts
treatment = c("control", "control", "control", "hhp.10min", "hhp.10min", "hhp.10min",
    "hhp.2hr", "hhp.2hr", "hhp.2hr", "hhp.24hr", "hhp.24hr", "hhp.24hr")
batch = c("first", "second", "third", "first", "second", "third", "first", "second",
    "third", "first", "second", "third")
```

```{r}
groups = sapply(as.character(treatment), switch, control = 1, hhp.10min = 2, hhp.2hr = 3,
    hhp.24hr = 4, USE.NAMES = F)
batches = sapply(as.character(batch), switch, first = 1, second = 2, third = 3, USE.NAMES = F)
# create levels to compare
```

```{r}
groups
batches
```

```{r}
x_corrected_counts <- ComBat_seq(counts = as.matrix(x), batch = batches, group = groups)
# transform counts
```

```{r}
head(x$counts)
head(x_corrected_counts)
```

```{r}
x$counts <- x_corrected_counts
```

## Filter lowly expressed gene, obatain CPMS

```{r}
# Filtering lowly expressed genes Obtain CPMs
myCPM <- cpm(x)
# Have a look at the output
head(myCPM)
# Which values in myCPM are greater than 0.33?  A CPM of 0.33 is used as it
# corresponds to a count of 10-15 for the library sizes in this data set.  If
# the count is any smaller, it is considered to be very low, indicating that
# the associated gene is not expressed in that sample.  Let's have a look and
# see whether our threshold of 0.33 does indeed correspond to a count of about
# 10-15 We will look at the first sample
thresh <- myCPM > 0.33
# This produces a logical matrix with TRUEs and FALSEs
head(thresh)
# Summary of how many TRUEs there are in each row There are 11433 genes that
# have TRUEs in all 12 samples.
table(rowSums(thresh))
# we would like to keep genes that have at least 2 TRUES in each row of thresh
keep <- rowSums(thresh) >= 2
table(keep)
```

```{r}
plot(myCPM[, 1], x$counts[, 1])
# Let us limit the x and y-axis so we can actually look to see what is
# happening at the smaller counts
```

```{r}
plot(myCPM[, 1], x$counts[, 1], ylim = c(0, 50), xlim = c(0, 3))
# Add a vertical line at 0.5 CPM
abline(v = 0.33, h = 15, col = "blue")
# Now that we've checked our filtering method we will filter the DGEList
# object.)  Let us limit the x and y-axis so we can actually look to see what
# is happening at the smaller counts
```

```{r}
# Now that we've checked our filtering method we will filter the DGEList
# object.
x <- x[keep, keep.lib.sizes = FALSE]
```

```{r}
dim(x)
head(x)
```

## Quality control

```{r}
# Quality control Library size and distribution plots First, we can check how
# many reads we have for each sample in the y.
x$samples$lib.size
# The names argument tells the barplot to use the sample names on the x-axis
# The las argument rotates the axis names
barplot(x$samples$lib.size, names = colnames(x), las = 2)
# Add a title to the plot
title("Barplot of library sizes")
```

```{r}
# we can also adjust the labelling if we want
barplot(x$samples$lib.size/1e+06, names = colnames(x), las = 2, ann = FALSE, cex.names = 0.75)
mtext(side = 1, text = "Samples", line = 0.5)
mtext(side = 2, text = "Library size (millions)", line = 3)
title("Barplot of library sizes")
```

```{r}
# Count data is not normally distributed, so if we want to examine the
# distributions of the raw counts we need to log the counts.  Get log2 counts
# per million
logcounts <- cpm(x, log = TRUE, prior.count = 1)
# Check distributions of samples using boxplots
boxplot(logcounts, xlab = "", ylab = "Log2 counts per million", las = 2)
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h = median(logcounts), col = "blue")
title("Boxplots of logCPMs (unnormalised)")
```

```{r}
saveRDS(logcounts, "./output/for_publication/logcounts.rds")
```

```{r}
list_markers <- c("Calca", "Mrgprd", "Nefh", "Scn10a", "Stmn2", "Tac1", "Tubb3", "Apoe", "Ednrb", "Gfap", "Fabp7", "Mpzl1", "Cldn5", "Flt1", "Esam")
counts <- 2**(logcounts[list_markers, ]) -1
counts
```

```{r}
write_csv(as.data.frame(counts), "1.csv")
```

## Multidimensional scaling plots 

```{r}
# An MDSplot is a visualisation of a principle components analysis, which
# determines the greatest sources of variation in the data.
plotMDS(x)
```

```{r}
# Redo the MDSplot with corrected information
col.cell <- c("purple", "orange", "red", "blue")[sampleinfo$Treatment]
col.status <- c("#1B9E77", "#D95F02", "#7570B3")[sampleinfo$Batch]
char.celltype <- c(1, 4)[sampleinfo$Treatment]
plotMDS(x, col = col.cell)
legend("bottom", fill = c("purple", "orange", "red", "blue"), legend = levels(sampleinfo$Treatment))
title("Treatment")

p1 <- plotMDS(x, col = col.status)
legend("bottom", fill = c("#1B9E77", "#D95F02", "#7570B3"), legend = levels(sampleinfo$Batch),
    cex = 0.8)
title("Batch")
```

```{r}
char.status <- c(1, 3, 3)[sampleinfo$Batch]
plotMDS(x, dim = c(1, 2), col = col.cell, pch = char.status, cex = 1.5)
legend("bottom", legend = levels(sampleinfo$Treatment), col = c("purple", "orange",
    "red", "blue"), pch = 16)
legend("right", legend = levels(sampleinfo$Batch), pch = c(16, 3, 4))
```

## Hierarchical clustering with heatmaps

```{r}
# Let's select data for the 500 most variable genes and plot the heatmap We
# estimate the variance for each row in the logcounts matrix
var_genes <- apply(logcounts, 1, var)
head(var_genes)
# Get the gene names for the top 500 most variable genes
select_var <- names(sort(var_genes, decreasing = TRUE))[1:50]
head(select_var)
# Subset logcounts matrix
highly_variable_lcpm <- logcounts[select_var, ]
dim(highly_variable_lcpm)
head(highly_variable_lcpm)
```

```{r}
## Get some nicer colours
mypalette <- brewer.pal(11, "RdYlBu")
morecols <- colorRampPalette(mypalette)
# Set up colour vector for celltype variable
col.status <- c("#1B9E77", "#D95F02", "#7570B3")[sampleinfo$Batch]
# Plot the heatmap
heatmap.2(highly_variable_lcpm, scale = "row", col = rev(morecols(100)), trace = "none",
    main = "Top 50 most variable
genes across samples", ColSideColors = col.status)
```

## Normalisation for composition bias

```{r}
# The calcNormFactors function calculates the normalization factors between
# libraries.  TMM normalisation (and most scaling normalisation methods) scale
# relative to one sample.  Apply normalisation to DGEList object
x <- calcNormFactors(x)
x$samples
# The last two samples have much smaller normalisation factors, and MCL1.LA and
# MCL1.LB have the largest.  If we plot mean difference plots using the plotMD
# function for these samples, we should be able to see the composition bias
# problem.
par(mfrow = c(1, 2))
plotMD(logcounts, column = 1)
abline(h = 0, col = "grey")
plotMD(logcounts, column = 4)
abline(h = 0, col = "grey")
# if we redo these plots using y, we should see the composition bias problem
# has been solved.
par(mfrow = c(1, 2))
plotMD(x, column = 1)
abline(h = 0, col = "grey")
plotMD(x, column = 4)
abline(h = 0, col = "grey")
# Plot the biased and unbiased MD plots side by side for the same sample to see
# the before and after TMM normalisation effect.
par(mfrow = c(1, 2))
plotMD(logcounts, column = 3, main = "Before TMM normalisation")
abline(h = 0, col = "grey")
plotMD(x, column = 3, main = "After TMM normalisation")
abline(h = 0, col = "grey")
```

```{r}
x
```

```{r}
saveRDS(x, "./output/x_with_correction.rds")
```

## Differential expression with limma-voom

```{r}
x <- readRDS("./output/x_with_correction.rds")
summary(x)
```

```{r}
# Create the design matrix Look at group variable again
treatment <- sampleinfo$Treatment
# Take a look
treatment
# Convert to factor
treatment <- factor(treatment)
# Specify a design matrix without an intercept term
design <- model.matrix(~0 + treatment)
design
# Make the column names of the design matrix a bit nicer
colnames(design) <- levels(treatment)
design
```

```{r}
# Voom transform the data
v <- voom(x, design, plot = TRUE)
head(v)
# What is contained in this object?
names(v)
dim(v$weights)
# We can repeat the box plots for the normalised data to compare to before
# normalisation.  The expression values in v$E are already log2 values so we
# don't need to log-transform.
par(mfrow = c(1, 2))
boxplot(logcounts, xlab = "", ylab = "Log2 counts per million", las = 2, main = "Unnormalised logCPM")
## Let's add a blue horizontal line that corresponds to the median logCPM
abline(h = median(logcounts), col = "blue")
boxplot(v$E, xlab = "", ylab = "Log2 counts per million", las = 2, main = "Voom transformed logCPM")
## Let's add a blue horizontal line that corresponds to the median logCPM
abline(h = median(v$E), col = "blue")
```

```{r}
x["Tubb3", ]$counts / x$samples$lib.size
```

## Testing for differential expression, contro vs HHP.24h

```{r}
# Now that we have the voom transformed data we can use limma to test for
# differential expression.  Fit the linear model
fit <- lmFit(v)
names(fit)
# The comparison of interest can be specified using the makeContrasts function.
cont.matrix <- makeContrasts(convs24h = hhp.24hr - control, levels = design)
cont.matrix
# Now we can apply the contrasts matrix to the fit object to get the statistics
# and estimated parameters of our comparison that we are interested in.  Now we
# can apply the contrasts matrix to the fit object to get the statistics and
# estimated parameters of our comparison that we are interested in.
fit.cont.B <- contrasts.fit(fit, cont.matrix)
# The final step is to call the eBayes function, which performs empirical Bayes
# shrinkage on the variances, and estimates moderated t-statistics and the
# associated p-values.
fit.cont.B <- eBayes(fit.cont.B)
# Check the dimensions of the fit object
dim(fit.cont.B)
# We can use the limma decideTests function to generate a quick summary of DE
# genes for the contrasts.
summa.fit.B <- decideTests(fit.cont.B, lfc = 0.5)
summary(summa.fit.B)
```

```{r}
head(fit.cont.B)
```

```{r}
seq_tab <- topTable(fit.cont.B,adjust="BH",n=Inf)
head(seq_tab)
```

```{r}
saveRDS(summa.fit.B, "./output/for_publication/summa.fit.B.rds")
```

```{r}
write.csv(seq_tab, "RNA-seqResults-Convs24h.csv")
```

```{r}
saveRDS(seq_tab, "./output/for_publication/seq_tab.rds")
```

## Plots after testing for DE

```{r}
# We want to highlight the significant genes. We can get this from decideTests.
plotMD(fit.cont.B, coef = 1, status = summa.fit.B[, "convs24h"], values = c(-1, 1),
    hl.col = c("blue", "red"))
# For the volcano plot we have to specify how many of the top genes to
# highlight.  We can also specify that we want to plot the gene symbol for the
# highlighted genes.  let's highlight the top 100 most DE genes
volcanoplot(fit.cont.B, coef = 1,  names = fit.cont.B$genes$SYMBOL,
    main = "convs24h")
# ook at the MD plot and volcano plot for the second comparison, L.PregVsLac.
# Change the number of highlighted genes to 200 in the volcano plot.
```

```{r}
# It is recommended to have a look at the expression levels of the individual
# samples for the genes of interest.
par(mfrow = c(2, 2))
nice.col <- brewer.pal(6, name = "Dark2")
stripchart(v$E["Gdf15", ] ~ treatment, vertical = TRUE, las = 2, cex.axis = 0.8,
    pch = 16, cex = 1.3, col = nice.col, method = "jitter", ylab = "Normalised log2 expression",
    main = "Gdf15")
stripchart(v$E["Fgf22", ] ~ treatment, vertical = TRUE, las = 2, cex.axis = 0.8,
    pch = 16, cex = 1.3, col = nice.col, method = "jitter", ylab = "Normalised log2 expression",
    main = "Fgf22")
stripchart(v$E["Tac1", ] ~ treatment, vertical = TRUE, las = 2, cex.axis = 0.8, pch = 16,
    cex = 1.3, col = nice.col, method = "jitter", ylab = "Normalised log2 expression",
    main = "Tac1")
stripchart(v$E["C1qtnf4", ] ~ treatment, vertical = TRUE, las = 2, cex.axis = 0.8,
    pch = 16, cex = 1.3, col = nice.col, method = "jitter", ylab = "Normalised log2 expression",
    main = "C1qtnf4")
```

```{r}
par(mfrow = c(2, 4))
gene_list <- c("Gdf15", "Fgf22", "Tac1", "Wnt16", "C1qtnf4", "Nppb", "Cer1", "Wnt2b")
for (i in gene_list) {
    stripchart(v$E[i, ] ~ treatment, vertical = TRUE, las = 2, cex.axis = 0.8, pch = 16,
        cex = 1.3, col = nice.col, method = "jitter", ylab = "Normalised log2 expression",
        main = i)
}
```

```{r}
par(mfrow = c(3, 4))
gene_list <- c("Gdf15", "Wnt16", "C1qtnf4", "Cer1", "Wnt2b", "Flt3l", "Bmp8a", "Il7",
    "Sectm1b", "Tnfsf13b", "Areg")
for (i in gene_list) {
    stripchart(v$E[i, ] ~ treatment, vertical = TRUE, las = 2, cex.axis = 0.8, pch = 16,
        cex = 1.3, col = nice.col, method = "jitter", ylab = "Normalised log2 expression",
        main = i)
}
```

```{r}
par(mfrow = c(1, 3))
gene_list <- c("Slc30a1", "Slc39a10", "Slc39a11")
for (i in gene_list) {
    stripchart(v$E[i, ] ~ treatment, vertical = TRUE, las = 2, cex.axis = 0.8, pch = 16,
        cex = 1.3, col = nice.col, method = "jitter", ylab = "Normalised log2 expression",
        main = i)
}
```

## Testing for differential expression, contro vs HHP.2h

```{r}
# Now that we have the voom transformed data we can use limma to test for
# differential expression.  Fit the linear model
fit <- lmFit(v)
names(fit)
# The comparison of interest can be specified using the makeContrasts function.
cont.matrix <- makeContrasts(convs2h = hhp.2hr - control, levels = design)
cont.matrix
# Now we can apply the contrasts matrix to the fit object to get the statistics
# and estimated parameters of our comparison that we are interested in.  Now we
# can apply the contrasts matrix to the fit object to get the statistics and
# estimated parameters of our comparison that we are interested in.
fit.cont.B <- contrasts.fit(fit, cont.matrix)
# The final step is to call the eBayes function, which performs empirical Bayes
# shrinkage on the variances, and estimates moderated t-statistics and the
# associated p-values.
fit.cont.B <- eBayes(fit.cont.B)
# Check the dimensions of the fit object
dim(fit.cont.B)
# We can use the limma decideTests function to generate a quick summary of DE
# genes for the contrasts.
summa.fit.B <- decideTests(fit.cont.B)
summary(summa.fit.B)
```

```{r}
seq_tab <- topTable(fit.cont.B,adjust="BH",n=Inf)
head(seq_tab)
```

```{r}
write.csv(seq_tab, "RNA-seqResults-Convs2h.csv")
```

## Testing for differential expression, contro vs HHP.10min

```{r}
# Now that we have the voom transformed data we can use limma to test for
# differential expression.  Fit the linear model
fit <- lmFit(v)
names(fit)
# The comparison of interest can be specified using the makeContrasts function.
cont.matrix <- makeContrasts(convs2h = hhp.10min - control, levels = design)
cont.matrix
# Now we can apply the contrasts matrix to the fit object to get the statistics
# and estimated parameters of our comparison that we are interested in.  Now we
# can apply the contrasts matrix to the fit object to get the statistics and
# estimated parameters of our comparison that we are interested in.
fit.cont.B <- contrasts.fit(fit, cont.matrix)
# The final step is to call the eBayes function, which performs empirical Bayes
# shrinkage on the variances, and estimates moderated t-statistics and the
# associated p-values.
fit.cont.B <- eBayes(fit.cont.B)
# Check the dimensions of the fit object
dim(fit.cont.B)
# We can use the limma decideTests function to generate a quick summary of DE
# genes for the contrasts.
summa.fit.B <- decideTests(fit.cont.B)
summary(summa.fit.B)
```

```{r}
seq_tab <- topTable(fit.cont.B,adjust="BH",n=Inf)
head(seq_tab)
```

```{r}
write.csv(seq_tab, "RNA-seqResults-Convs10min.csv")
```

## Venn Diagram

```{r}
summary(summa.fit.B)
summary(summa.fit.L)
```

```{r}
rownames_to_column(as.data.frame(summa.fit.L))
```

```{r}
summa.fit.B <- rownames_to_column(as.data.frame(summa.fit.B)) %>%
    rename(ComBat_seq = "convs24h")
summa.fit.L <- rownames_to_column(as.data.frame(summa.fit.L)) %>%
    rename(edgeR = "treatmenthhp.24hr")
c3 <- left_join(summa.fit.B, summa.fit.L, by = "rowname")
c3 <- column_to_rownames(c3, var = "rowname")
head(c3)
dim(c3)
```

```{r}
# Add another contrast to the contrasts matrix, check out the vennDiagram
# function c3 <- cbind(summa.fit.B, summa.fit.L)
head(c3)
vennDiagram(c3, include = c("up", "down"), names = c("ComBat_seq", "edgeR"), counts.col = c("red",
    "blue"), circle.col = c("turquoise", "salmon"))
```

```{r}
summa.fit.B.common <- summa.fit.B[summa.fit.B == summa.fit.L, ] 
head(summa.fit.B.common)
```

```{r}
saveRDS(summa.fit.B.common, "summa.fit.B.rds")
```

## Testing relative to a threshold (TREAT)

```{r}
# In other words, you are not controlling the false discovery rate at 5% any
# more. There is a function called treat in the limma package that performs
# this style of analysis correctly (McCarthy and Smyth 2009).  Let's decide
# that we are only interested in genes that have a absolute logFC of 1.  This
# corresponds to a fold change of 2, or 0.5 (i.e.  double or half).  We can
# perform a treat analysis which ranks our genes according to p-value AND
# logFC.  This is easy to do after our analysis, we just give the treat
# function the fit.cont object and specify our cut-off.
fit.treat.B <- treat(fit.cont.B, lfc = 0.3)
res.treat.B <- decideTests(fit.treat.B)
summary(res.treat.B)

# Calculate the treat seperately
topTable(fit.treat.B, coef = 1, sort.by = "p")
# Notice that much fewer genes are highlighted in the MAplot
par(mfrow = c(1, 2))
plotMD(fit.treat.B, coef = 1, status = res.treat.B[, "convs24h"], values = c(-1,
    1), hl.col = c("blue", "red"))
abline(h = 0, col = "grey")

# An interactive version of the mean-difference plots is possible via the
# glMDPlot function in the Glimma package.
glMDPlot(fit.treat.B, coef = 1, counts = v$E, groups = treatment, status = res.treat.B,
    side.main = "ENTREZID", main = "convs24h", folder = "md")
```

```{r}
topTable(fit.treat.B, coef = 1, sort.by = "p")
```

## Select gene for GO analysis

```{r}
sum((c3$ComBat_seq == 1) & (c3$edgeR == 1))
```

```{r}
select_genes <- (c3$ComBat_seq == -1) & (c3$edgeR == -1)
head(select_genes)
```

```{r}
forGO <- fit.cont.B[select_genes ,]$coefficients
# choose the gene for further GO analysis
# differential genes after ComBat-seq correction
dim(forGO)
```

```{r}
write.csv(forGO, "forGO_down.csv")
```

```{r}
select_genes <- (c3$ComBat_seq == c3$edgeR)
head(select_genes)
```

```{r}
summa.fit.B <- summa.fit.B[select_genes, ]
```

```{r}
saveRDS(summa.fit.B, "./summa.fit.B_neuron.rds")
```

## Batch effect correction with limma

```{r}
batch <- sampleinfo$Batch
batch <- factor(batch)
treatment <- sampleinfo$Treatment
treatment <- factor(treatment)
design <- model.matrix(~treatment)
design
```

```{r}
# TMM-normalization.
x <- calcNormFactors(x)
head(x$counts)
# Convert to CPM and log2 transformation.
logCPM <- cpm(x, log = TRUE, prior.count = 1)
head(logCPM)
# Remove batch effect.
logCPM_no_batch <- removeBatchEffect(logCPM, batch = batch, design = design)
head(logCPM_no_batch)
```

```{r}
# Redo the MDSplot with corrected information
col.cell <- c("purple", "orange", "red", "blue")[sampleinfo$Treatment]
col.status <- c("#1B9E77", "#D95F02", "#7570B3")[sampleinfo$Batch]
char.celltype <- c(1, 4)[sampleinfo$Treatment]
plotMDS(logCPM, col = col.cell)
legend("bottom", fill = c("purple", "orange", "red", "blue"), legend = levels(sampleinfo$Treatment))
title("Treatment")

plotMDS(logCPM, col = col.status)
legend("bottom", fill = c("#1B9E77", "#D95F02", "#7570B3"), legend = levels(sampleinfo$Batch),
    cex = 0.8)
title("Batch")
```

```{r}
# Redo the MDSplot with corrected information
col.cell <- c("purple", "orange", "red", "blue")[sampleinfo$Treatment]
col.status <- c("#1B9E77", "#D95F02", "#7570B3")[sampleinfo$Batch]
char.celltype <- c(1, 4)[sampleinfo$Treatment]
plotMDS(logCPM_no_batch, col = col.cell)
legend("bottom", fill = c("purple", "orange", "red", "blue"), legend = levels(sampleinfo$Treatment))
title("Treatment")

plotMDS(logCPM_no_batch, col = col.status)
legend("bottom", fill = c("#1B9E77", "#D95F02", "#7570B3"), legend = levels(sampleinfo$Batch),
    cex = 0.8)
title("Batch")
```

```{r}
var_genes <- apply(logCPM, 1, var)
head(var_genes)
# Get the gene names for the top 500 most variable genes
select_var <- names(sort(var_genes, decreasing = TRUE))[1:50]
head(select_var)
```

```{r}
# Subset logcounts matrix
highly_variable_lcpm <- logCPM[select_var, ]
dim(highly_variable_lcpm)
head(highly_variable_lcpm)
# Get some nicer colours
mypalette <- brewer.pal(11, "RdYlBu")
morecols <- colorRampPalette(mypalette)
# Set up colour vector for celltype variable
col.status <- c("#1B9E77", "#D95F02", "#7570B3")[sampleinfo$Batch]
# Plot the heatmap
heatmap.2(highly_variable_lcpm, col = rev(morecols(100)), trace = "none", main = "Top 50 most variable
genes across samples",
    ColSideColors = col.status, scale = "row")
```

```{r}
# Subset logcounts matrix
highly_variable_lcpm <- logCPM_no_batch[select_var, ]
# Get some nicer colours
mypalette <- brewer.pal(11, "RdYlBu")
morecols <- colorRampPalette(mypalette)
# Set up colour vector for celltype variable
col.status <- c("#1B9E77", "#D95F02", "#7570B3")[sampleinfo$Batch]
# Plot the heatmap
heatmap.2(highly_variable_lcpm, col = rev(morecols(100)), trace = "none", main = "Top 50 most variable
genes across samples",
    ColSideColors = col.status, scale = "row")
```

## Differential expression after batch effect correction with edgeR

```{r}
x <- readRDS("./output/x_without_correction.rds")
summary(x)
```

```{r}
# Create the design matrix Look at group variable again
treatment <- sampleinfo$Treatment
treatment <- factor(treatment)
batch <- sampleinfo$Batch
batch <- factor(batch)
treatment
batch
```

```{r}
# Specify a design matrix without an intercept term Make the column names of
# the design matrix a bit nicer
design <- model.matrix(~batch + treatment)
rownames(design) <- colnames(x)
design
```

```{r}
x <- estimateDisp(x, design, robust = TRUE)
x$common.dispersion
plotBCV(x)
```

```{r}
fit <- glmQLFit(x, design, robust = TRUE)
plotQLDisp(fit)
```

```{r}
qlf <- glmQLFTest(fit, coef = 1:6)
topTags(qlf)
```

```{r}
FDR <- p.adjust(qlf$table$PValue, method = "BH")
sum(FDR < 0.05)
```

```{r}
qlf <- glmQLFTest(fit, coef = 5)
topTags(qlf)
```

```{r}
summa.fit.L <- decideTests(qlf, lfc = 0.5)
summary(summa.fit.L)
```

```{r}
top <- rownames(topTags(qlf))
cpm(x)[top, ]
```

```{r}
plotMD(qlf)
abline(h = c(-1, 1), col = "blue")
```

```{r}
saveRDS(summa.fit.L, "./output/for_publication/summa.fit.L.rds")
```

## Genes of interests with heatmaps

```{r}
receptor_ligand_activity <- c("Gdf15", "Fgf22", "Tac1", "Wnt16", "C1qtnf4", "Nppb",
    "Cer1", "Wnt2b", "Sema3e", "Flt3l", "Bmp8a", "Mdk", "Pomc", "Il7")
cytokine_activity <- c("Gdf15", "Wnt16", "C1qtnf4", "Cer1", "Wnt2b", "Flt3l", "Bmp8a",
    "Il7")
atp_activity <- c("Helz", "Dna2", "Abcc8", "Mcm8", "Entpd2", "Rfc5", "Mfsd2a", "Kifc1",
    "Atad5", "Kif18a", "Brip1", "Atp8b3", "Mcm4", "Kif20b", "Rad51b", "Atp10a", "Rad54b",
    "Hells", "Mcm2", "Pif1", "Ercc6l", "Mcm6", "Polq", "Mcm3", "Katnal2", "Rad51",
    "Fignl1", "Chtf18", "Kif20a", "Cenpe", "Kif18b", "Kif23", "Kif14", "Kif2c", "Kif15",
    "Kif11", "Mcm5", "Rad54l", "Top2a")
```

```{r}
slcs <- c("Slc30a1", "Slc39a10", "Slc39a11")
```

```{r}
tubulin_binding <- c("Traf3ip1", "Haus7", "Kifc1", "Kif18a", "Rgs14", "Kif20b", "Gli1",
    "Knstrn", "Tpx2", "Kif24", "Birc5", "Brca2", "Nusap1", "Spag5", "Ska1", "Kif20a",
    "Prc1", "Cenpe", "Kif18b", "Racgap1", "Fam83d", "Kif4", "Plk1", "Kif23", "Dlgap5",
    "Kif14", "Kif2c", "Kif15", "Kif11", "Dcx")
```

```{r}
ion_channels_up <- c("Abcc9", "Atp6v1f", "Atp6v1h", "Atp13a4", "Cacna1i", "Clca1",
    "Clca2", "Clcn2", "Cnr1", "Hrh1", "Kcna4", "Kcnh3", "Kcnh5", "Kcnj6", "Kcnj8",
    "Kcnk6", "Kcnmb1", "Kcnn1", "Kcns3", "Panx1", "Pex5l", "Pkd1l2", "Pkd2l1", "Psen1",
    "Scn1b", "Scn5a", "Sfxn4", "Slc2a3", "Slc5a7", "Slc8b1", "Slc9a8", "Slc15a2",
    "Slc16a12", "Slc22a4", "Slc25a2", "Slc25a20", "Slc25a38", "Slc26a11", "Slc35b3",
    "Slc38a6", "Slc39a10", "Slc45a1", "Slc52a2", "Slc52a3", "Stim1", "Tmem38a", "Tpcn2",
    "Trpa1", "Trpm1", "Trpv2")
```

```{r}
ion_channels_down <- c("Abcc8", "Atp1a2", "Cachd1", "Cacna1d", "Cacna1e", "Cacng2",
    "Clcc1", "Clcn5", "Clic4", "Cnnm2", "Cpox", "Gabra5", "Gabrb3", "Gjc1", "Gria2",
    "Gria4", "Grid2", "Grik1", "Hcn4", "Itgav", "Itpr1", "Itpr3", "Kcna2", "Kcnab1",
    "Kcnf1", "Kcng1", "Kcnh6", "Kcnip2", "Kcnj10", "Kcnj16", "Kcnk10", "Kcnk18",
    "Kcnn4", "Lasp1", "Lrrc8c", "Mfsd2a", "Mfsd10", "Nipal1", "Pkd2", "Pkdrej", "Rasa3",
    "Scn2b", "Scn8a", "Sec61a1", "Sfxn5", "Slc1a1", "Slc1a2", "Slc2a10", "Slc2a13",
    "Slc4a4", "Slc4a7", "Slc7a2", "Slc8a1", "Slc9a1", "Slc12a4", "Slc16a7", "Slc19a1",
    "Slc24a3", "Slc25a13", "Slc25a15", "Slc25a23", "Slc25a29", "Slc30a1", "Slc30a4",
    "Slc35b4", "Slc39a11", "Slco3a1", "Stim2", "Tmem150c", "Tomm40", "Trpc3", "Ttyh1",
    "Ttyh2", "Ttyh3", "Xpr1")
```

```{r}
gene_list <- ion_channels_down
head(gene_list)
# Subset logcounts matrix
highly_variable_lcpm <- logcounts[gene_list, ]
dim(highly_variable_lcpm)
head(highly_variable_lcpm)
```

```{r}
## Get some nicer colours
mypalette <- brewer.pal(11, "RdYlBu")
morecols <- colorRampPalette(mypalette)
# Set up colour vector for celltype variable
col.status <- c("#1B9E77", "#D95F02", "#7570B3")[sampleinfo$Batch]
# Plot the heatmap
heatmap.2(highly_variable_lcpm, col = rev(morecols(100)), ColSideColors = col.status,
    scale = "row", dendrogram = "none", Rowv = FALSE, Colv = FALSE, trace = "none",
    main = "Top 50 most variable
genes across samples", )
```

